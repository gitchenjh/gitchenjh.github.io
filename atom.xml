<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gitchenjh.github.io/</id>
    <title>gitchenjh 博客</title>
    <updated>2019-07-26T10:24:45.087Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gitchenjh.github.io/"/>
    <link rel="self" href="https://gitchenjh.github.io//atom.xml"/>
    <subtitle>gitchenjh 博客</subtitle>
    <logo>https://gitchenjh.github.io//images/avatar.png</logo>
    <icon>https://gitchenjh.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, gitchenjh 博客</rights>
    <entry>
        <title type="html"><![CDATA[计算机数字的表示]]></title>
        <id>https://gitchenjh.github.io//post/ji-suan-ji-shu-zi-de-biao-shi</id>
        <link href="https://gitchenjh.github.io//post/ji-suan-ji-shu-zi-de-biao-shi">
        </link>
        <updated>2019-07-26T10:19:31.000Z</updated>
        <content type="html"><![CDATA[<p>我们知道计算机底层都是使用二进制来操作的，但是生活中我们更习惯使用十进制来计算和表示. 这其中又有什么关系呢？所以在阅读此文章之前，我们先问自己一下两个问题：</p>
<p><strong>1.我们生活中常用的数字如何在计算机中使用二进制表示</strong></p>
<p><strong>2.这些数如何在计算机中做数字运算。</strong></p>
<h2 id="一-常用进制">一、常用进制</h2>
<p>对于习惯使用十个手指头的人类来说，早已习惯使用数字1~10来表示我们生活的数字。 我们也称之为十进制数。</p>
<p>但现在使用过计算机的人来说都知道计算机底层采用的都是二进制数来表示，这是由于依赖于底层电器信号的限制我们只能模拟出低电频和(0)和高电频(1)的信号,自然使用数字<strong>0</strong>和<strong>1</strong>表示最为合适. 但这种表示方法对于人来说不易读而且表示冗长;所以,向上又使用了十六进制来表示，使其变得易读。</p>
<h4 id="二进制">二进制</h4>
<p>二进制，也就是由<strong>0</strong>和<strong>1</strong>组成,用来表示一个十进制<strong>5</strong>数如下:</p>
<pre><code class="language-python">0000 0101
</code></pre>
<p>二进制数是可以计算的,也可以做逻辑运算,如我们计算一个十进制<strong>5</strong>加<strong>3</strong>:</p>
<pre><code class="language-python">  0000 0101
+ 0000 0011    #逢二进一
= 0000 1000
</code></pre>
<h4 id="十进制">十进制</h4>
<p>这个掰一掰手指就知道了,就不多说了。</p>
<h4 id="十六进制">十六进制</h4>
<p><strong>十六进制</strong> 在数学上是一种逢16进1的进位制。用数字0<sub>9和字母A</sub>F表示。</p>
<p>​																                                                                                           ---------- 百度百科</p>
<p>十六进制的转换也很简单,介绍下二进制和十进制分别转换为16进制。</p>
<p>二进制数中每四位组成一个十六进制数，如下:</p>
<pre><code class="language-python">  0011 1011 0111 1110
     3   B     7    E
</code></pre>
<p>十进制转十六进制只要除十六取模，和十进制转二进制类似:</p>
<pre><code class="language-python">4877÷16=304....13(D)
304÷16=19....0
19÷16=1....3
1÷16=0....1
---------------
130D
</code></pre>
<p>在C语言中，以<code>0x</code>或者<code>0X</code>开头的数字常量被认为是十六进制的值。</p>
<h2 id="二-数字编码">二、数字编码</h2>
<p>我们知道现在计算机普遍使用二进制来表示，这是因为二进制能够工作的更好。对于二进制数来说，单独的讲某一个位没有太多的意义，但是可以将多个位组合起来，再加上某种解释，就可以用来表示我们日常生活中常用的数字。 计算机中常用表示的数又分为<strong>有符号数</strong>、<strong>无符号数</strong>和<strong>浮点数</strong>。</p>
<h4 id="无符号">无符号</h4>
<p>无符号表示大于或者等于0的数字，是基于传统的二进制表示法进行编码。</p>
<p>对于一个十进制数来说,如果我们想表示<code>999</code>这个数，我们也可以写成<code>9*10^2+9*10^1+9*10^0</code>.对于用二进制来表示表示就更简单了,二进制的每一个位的取值只有两种情况<strong>0</strong>或者<strong>1</strong>. 对于一个8位的二进制<strong>10110011</strong>数表示如下:</p>
<pre><code>$$
1*2^7+0*2^6+1*2^5+1*2^4+0*2^3+0*2^2+1*2^1+1*2^0   =&gt; \sum_{}^{i}*{2^i}
$$
</code></pre>
<p>如上，该数字表示十进制数为<strong>179</strong>，对于<strong>8</strong>位的二进制数我们能够表示的范围为0(00000000)~255(11111111).</p>
<p>无符号的二进制数表示一个很重要的特性，也就是对于任何介于0~2^w-1 之间的数值都有一个唯一w为的值编码。</p>
<h4 id="有符号数">有符号数</h4>
<p>有符号数表示可以为正或者为负的数字，通常采用<strong>补码</strong>进行编码。 负数是有符号的数值,对于负数来说，我们最难的就是如何表示它的负号.先来看看什么是<strong>原码</strong>、<strong>补码</strong>、<strong>反码</strong>。</p>
<p><strong>原码</strong></p>
<p>原码是计算机中数字的二进制定点表示法。数码序列中最高位表示符号位，符号0表示正数，符号1表示负数;其余位表示数值的大小。这样我们使用一个符号位的引用就可以表示正数、负数。对于一个8位二进制数来说，能够表示的范围就是-127(1111 1111)~127(0111 1111)。 但对于原码表示有一个致命的缺点，就是不能参加运算。例如：-1(1000 0001) + 1(0000 0001) = 0(1000 0010) 这个二进制数的实际数值是-2.这显然不对。</p>
<p><strong>反码</strong></p>
<p>如果一个数是正数，那么这个数的反码就是它本身。 负数的反码是在原码的基础上，符号位不变，数值位按位取反。这样对于上述-1+1等于-2的问题就解决了。0001 + 1110(-1的反码) = 1111(反码) 转换到对应的数为-0. 但这又带来了一个问题.即0这个数有两种表示法+0和-0。</p>
<p><strong>补码</strong></p>
<p>补码的表示也分为两种，正数的补码是其原码本身，负数的补码是在其反码基础上再加1。</p>
<p>例如：</p>
<p>【+7】补码 = 0000 0111</p>
<p>【-7】 补码 = 1111 1001</p>
<p>我们使用补码来计算时，如果丢弃最高位对的进位，正负相加的确是为0的。</p>
<p>至此，我们可以使用补码来表示我们生活中常用的正数、负数；当然，这是我们丢弃了最高位的代价来换取的。</p>
<h4 id="定点数">定点数</h4>
<p>从名字来看，我们直观上可以理解为小数点为定点。当然定点数也是用来表示小数的，采用的是BCD码来编码。BCD码将0<sub>9中的每个数用4位二进制数来表示，这样对于32位就可以表示8个数字，表示的数字范围也就是0</sub>999999.99之间的1亿个实数。</p>
<p>BCD编码也有很多用途，比如银行、超市这种需要用到小数记金额的情况就很合适，但是如果表示很小、或者很大的数就不是很合适了，比如地球到太阳的距离，一个氢原子的半径等等。而且这样编码非常浪费，对于32位整数我们可以表示将近40亿个数字，而BCD编码的数字只能表示1亿个数字。</p>
<h4 id="浮点数">浮点数</h4>
<p>上面讨论了使用补码表示负数、正数。但是对于浮点数来说补码就无能为力了。 计算机中另一种表示小数的方法是采用了类似于科学计数法的方式来表示浮点数(还有一种方式叫做定点格式)。这个制定的规则由美国电气和电子工程师协会（IEEE，全称是Institute of Electrical and Electronics Engineers）制定的.浮点数的标准定义了两种基本的格式：以4个字节表示的单精度和以8个字节表示的双精度格式。</p>
<p>IEEE表示的浮点数格式为:</p>
<pre><code>$$
(-1)^s * M * 2^E
$$
</code></pre>
<p>对于单精度的表示法这三个部分一共32位，也就是4字节. s占1位；M占23位；E占8位。在双精度浮点格式中这三部分一共占64位。s占1位；M占52位；E占11位。</p>
<ul>
<li>符号s决定了这个数是负数(s=1)还是正数(s=0),对于数值0的符号位解释做特殊处理。</li>
<li>尾数M是一个二进制小数位数，只存储23位。</li>
<li>阶码E 的作用是对浮点数加权,这个权重是2的E次幂. 对于有符号指数，</li>
</ul>
<p>以上的表达式所表示的编码值又分为三种情况: <strong>规格化的值</strong>、<strong>非规格化的值</strong>、<strong>特殊值</strong>。</p>
<p><strong>规格化的值</strong></p>
<p>这种情况表示E的位数值既不全为0,也不全为1. 阶码会被认为一个有符号的数值,其数值要被减去一个2^(k-1)-1的偏置值(bias),对于单精度来说表达式也就改写为如下形式,偏置值得数值范围为(-126~+127).</p>
<pre><code>$$
（-1）^s * 1.f * 2^(e-127)
$$
</code></pre>
<p>对于M来说,我们它的大小可以通过调整E的值来确保M在范围1&lt;=M&lt;2之间。那么我们可以定义尾数M为M=1+f；这是一种轻松获取额外精度位的技巧(既然第一位总是为1，那么我们就不需要显示的表示它)；这种方式也叫做<strong>隐含以1开头的表示</strong>。</p>
<p><strong>非格化的值</strong></p>
<p>当阶码为全0时，所表示的数就是非格式化形式，此时阶码值为E=1-bias(偏置值).而尾数M的数值也就等于f. 此种格式是有两种情况:</p>
<ul>
<li>e=0 且f=0. 则该数为0.这种情况下32位都设置为0. 符号位s可以表示0或1。</li>
<li>e=0 且f!=0.  该数也是合法的</li>
</ul>
<p><strong>特殊值</strong></p>
<p>当阶码全为1时，所表示的数是一个特殊值:</p>
<ul>
<li>e=255 且f=0 这个数表示无穷大或者无穷小,这取决于符号位s的值。</li>
<li>e=255 且f!=0,该值被解释为“不是一个数”,通常使用<strong>NaN</strong>表示。</li>
</ul>
<p>对于一个8格式浮点数，其中e为4位，f为3位的浮点数表示如下:</p>
<p><img src="https://gitchenjh.github.io//post-images/1564136475774.jpg" alt=""></p>
<h2 id="三-数字运算">三、数字运算</h2>
<p>以上，我们介绍了如何用二进制表示一个十进制的正数、负数、浮点数。可以发现，采用不同的编码方式所表示的数范围不同。介绍完了数字如何用二进制表示，我们来看看如果使用二进制做我们常见的算术运算。</p>
<p>注： 在里没有特殊表示的情况下都采用4位二进制数来运算。</p>
<h4 id="无符号数加法">无符号数加法</h4>
<p>对于一个4位的无符号数，我们可以表示的数字范围是0~15. 如果我们取两个数x=11,y=14;那么这两个数字的和(25)并不能被4位的数字范围所表示. 而需要5位来表示，这也就产我们常说的产生了溢出.</p>
<p>对于一个w位的数字来说，两个数相加,我们可以得到如下结论:</p>
<p><img src="https://gitchenjh.github.io//post-images/1564136521597.jpg" alt=""></p>
<p>对于x+y，如果两个数的和小于2<sup>w所表示的最大的数时,其结果表示x+y本身，但是如果大于，就需要舍弃最高位，也就相当于从和中减去了2</sup>w.</p>
<h4 id="补码加法">补码加法</h4>
<p>对于补码的加法运算来说会产生三种情况,<code>结果太小</code>、<code>正常</code>、<code>结果太大</code>. 三种情况如下:</p>
<p><img src="https://gitchenjh.github.io//post-images/1564136531515.jpg" alt=""></p>
<p>对于补码来说，两个数x+y的取值范围为<code>-2^w</code>~ <code>2^w-2</code>, 当和大于最大值时，我们说发生了正溢出，此时我们要减去最大值；当和小于最小值时，我们说发生了负溢出，此时要加上最大值。</p>
<h4 id="无符号乘法">无符号乘法</h4>
<p>两个无符号数的乘法产生的数值大小范围为0~(2<sup>w-1)</sup>2. 所表示的数可能需要2w为来表示. 但实际中我们一般只表示低w位代表的值.</p>
<p><img src="https://gitchenjh.github.io//post-images/1564136541274.jpg" alt=""></p>
<h4 id="补码乘法">补码乘法</h4>
<p>两个有符号数的乘法取值范围为-2^(w-1) * (2^(w-1)-1) ~ (-2(w-1)) * (-2(w-1)).以一个四位为列，乘积所表示的范围为-56~86. 这个数也需要2w位.长我们也是将得到的数截断w位来实现的.这相当于将该值模上2^w,在将无符号数转换为补码.</p>
<p><img src="https://gitchenjh.github.io//post-images/1564136548088.jpg" alt=""></p>
<blockquote>
<p>U2T是一个将无符号数转换为补码的一个函数。</p>
</blockquote>
<h4 id="移位">移位</h4>
<p>不管是无符号数还是有符号数都可以通过移位来实现一个乘或者除一个2的k次幂的数.这在C语言中也叫做左移和右移操作,例如对于4位的数值11(1011),当左移两位时得到数值(101100),这个数所表示的无符号十进制也是44,将其截断后得到的数值便是1100(数值为12=44 mod 16).</p>
<p>在大多数机器上,整数的乘法指令相当慢,需要10个或者更多时钟周期,而对于其他整数运算(加法、移位)等只需要1个时钟周期,为此，编译器会使用一项重要的优化功能，C语言编译器会试图使用移位、加法、减法等组合来消除很多整数乘以常数的情况。如x * 14, 编译器会将重写为(x&lt;&lt;3) + (x &lt;&lt;2) + (x &lt;&lt;1),将一个乘法替换为三个移位和两个加法。</p>
<h2 id="四-总结">四、总结</h2>
<p>以上就是我们如何在计算机里面去表示一个有符号数、无符号数、浮点数，以及我们如何使用他们做常见的加减乘除运算。在实际中乘法、除法都是多指令周期的运算，在底层编译器中会使用移位、加法等组合来优化这样的指令计算。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[适用于spring-boot项目的反爬虫组件kk-anti-reptile]]></title>
        <id>https://gitchenjh.github.io//post/kk-anti-reptile</id>
        <link href="https://gitchenjh.github.io//post/kk-anti-reptile">
        </link>
        <updated>2019-07-19T03:03:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-概述">1. 概述</h2>
<p>kk-anti-reptile是<a href="https://www.keking.com">凯京科技</a>研发的，适用于<code>基于spring-boot开发的分布式系统</code>的反爬虫组件。</p>
<h2 id="2-系统要求">2. 系统要求</h2>
<ul>
<li>基于spring-boot开发(spring-boot1.x, spring-boot2.x均可)</li>
<li>需要使用redis</li>
</ul>
<h2 id="3-工作流程">3. 工作流程</h2>
<p>kk-anti-reptile使用基于Servlet规范的的Filter对请求进行过滤，在其内部通过spring-boot的扩展点机制，实例化一个Filter，并注入到Spring容器FilterRegistrationBean中，通过Spring注入到Servlet容器中，从而实现对请求的过滤</p>
<p>在kk-anti-reptile的过滤Filter内部，又通过责任链模式，将各种不同的过滤规则织入，并提供抽象接口，可由调用方进行规则扩展</p>
<p>Filter调用则链进行请求过滤，如过滤不通过，则拦截请求，返回状态码<code>509</code>，并输出验证码输入页面，输出验证码正确后，调用过滤规则链对规则进行重置</p>
<p>目前规则链中有如下两个规则</p>
<h3 id="ip-rule">ip-rule</h3>
<p>ip-rule通过时间窗口统计当前时间窗口内请求数，小于规定的最大请求数则可通过，否则不通过。时间窗口、最大请求数、ip白名单等均可配置</p>
<h3 id="ua-rule">ua-rule</h3>
<p>ua-rule通过判断请求携带的User-Agent，得到操作系统、设备信息、浏览器信息等，可配置各种维度对请求进行过滤</p>
<h2 id="4-接入使用">4. 接入使用</h2>
<p>后端接入非常简单，只需要引用kk-anti-reptile的maven依赖，并配置启用kk-anti-reptile即可<br>
加入maven依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;cn.keking.project&lt;/groupId&gt;
    &lt;artifactId&gt;kk-anti-reptile&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>配置启用 kk-anti-reptile</p>
<pre><code class="language-properties">anti.reptile.manager.enabled=true
</code></pre>
<p>前端需要在统一发送请求的ajax处加入拦截，拦截到请求返回状态码<code>509</code>后弹出一个新页面，并把响应内容转出到页面中，然后向页面中传入后端接口<code>baseUrl</code>参数即可，以使用axios请求为例：</p>
<pre><code class="language-javascript">import axios from 'axios';
import {baseUrl} from './config';

axios.interceptors.response.use(
  data =&gt; {
    return data;
  },
  error =&gt; {
    if (error.response.status === 509) {
      let html = error.response.data;
      let verifyWindow = window.open(&quot;&quot;,&quot;_blank&quot;,&quot;height=400,width=560&quot;);
      verifyWindow.document.write(html);
      verifyWindow.document.getElementById(&quot;baseUrl&quot;).value = baseUrl;
    }
  }
);

export default axios;
</code></pre>
<p>凯京科技内部用户可以访问 https://git.keking.cn/infrastructure/kk-antireptile-demo 查看接入示例</p>
<h2 id="5-注意">5. 注意</h2>
<ol>
<li>apollo-client需启用bootstrap</li>
</ol>
<p>使用apollo配置中心的用户，由于组件内部用到<code>@ConditionalOnProperty</code>，要在application.properties/bootstrap.properties中加入如下样例配置，(apollo-client需要0.10.0及以上版本）详见<a href="https://github.com/ctripcorp/apollo/wiki/Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97#3213-spring-boot%E9%9B%86%E6%88%90%E6%96%B9%E5%BC%8F%E6%8E%A8%E8%8D%90">apollo bootstrap说明</a></p>
<pre><code class="language-properties">apollo.bootstrap.enabled = true
</code></pre>
<ol start="2">
<li>需要有Redisson连接</li>
</ol>
<p>如果项目中有用到Redisson，kk-anti-reptile会自动获取RedissonClient实例对象; 如果没用到，需要在配置文件加入如下Redisson连接相关配置</p>
<pre><code class="language-properties">spring.redisson.address=redis://192.168.1.204:6379
spring.redisson.password=xxx
</code></pre>
<h2 id="6-配置一览表">6. 配置一览表</h2>
<p>在spring-boot中，所有配置在配置文件都会有自动提示和说明，如下图<br>
<img src="https://gitchenjh.github.io//post-images/1563505482779.png" alt="配置自动提示及说明"><br>
所有配置都以<code>anti.reptile.manager</code>为前缀，如下为所有配置项及说明</p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>描述</th>
<th>默认值</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>enabled</td>
<td>是否启用反爬虫插件</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>include-urls</td>
<td>需要反爬的接口列表，以'/'开头，以','分隔</td>
<td>空</td>
<td>/client,/user</td>
</tr>
<tr>
<td>ip-rule.enabled</td>
<td>是否启用IP Rule</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>ip-rule.expiration-time</td>
<td>时间窗口长度(ms)</td>
<td>5000</td>
<td>5000</td>
</tr>
<tr>
<td>ip-rule.request-max-size</td>
<td>单个时间窗口内，最大请求数</td>
<td>20</td>
<td>20</td>
</tr>
<tr>
<td>ip-rule.ignore-ip</td>
<td>IP白名单，支持后缀'*'通配，以','分隔</td>
<td>空</td>
<td>192.168.*,127.0.0.1</td>
</tr>
<tr>
<td>ua-rule.enabled</td>
<td>是否启用User-Agent Rule</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>ua-rule.allowed-linux</td>
<td>是否允许Linux系统访问</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>ua-rule.allowed-mobile</td>
<td>是否允许移动端设备访问</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>ua-rule.allowed-pc</td>
<td>是否允许移PC设备访问</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>ua-rule.allowed-iot</td>
<td>是否允许物联网设备访问</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>ua-rule.allowed-proxy</td>
<td>是否允许代理访问</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[bin-log-distributor消费数据丢失问题解决记录]]></title>
        <id>https://gitchenjh.github.io//post/bin-log-distributor_problem</id>
        <link href="https://gitchenjh.github.io//post/bin-log-distributor_problem">
        </link>
        <updated>2018-10-22T03:02:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="bin-log-distributor项目简介">bin-log-distributor项目简介</h2>
<p>bin-log-distributor是凯京科技开源的Mysql数据库数据变动实时监听分发中间件，详情见<a href="https://gitee.com/kekingcn/keking-binlog-distributor">码云开源地址</a>, <a href="https://github.com/kekingcn/keking-binlog-distributor">github开源地址</a></p>
<h2 id="背景">背景</h2>
<p>线上反馈有bin-log-distributor客户端偶尔有丢失数据的情况。</p>
<h2 id="验证方法">验证方法</h2>
<p>在装mysql的服务器上，使用多个线程并发循环对bin-log-distributor监控的数据表进行增、删、改。</p>
<h2 id="预期">预期</h2>
<p>bin-log-distributor客户端出现数据丢失。</p>
<h2 id="定位">定位</h2>
<p>分析客户端收到的数据，发现不仅有数据丢失，还有数据重复消费。<br>
将客户端日志打印更仔细，发现以下两点问题：</p>
<ol>
<li>从redis队列peek数据后，remove抛出如下异常：<br>
<img src="https://gitchenjh.github.io//post-images/1563160157405.jpg" alt=""></li>
<li>Redis队列数据没消费完其他线程异常进行了消费：<br>
<img src="https://gitchenjh.github.io//post-images/1563160179721.jpg" alt=""></li>
</ol>
<p>分析如下消费redis数据方法源码：</p>
<pre><code class="language-java">private void doRunWithLock() {
    RLock rLock = redissonClient.getLock(dataKeyLock);
    EventBaseDTO dto;
    try {
        RQueue&lt;EventBaseDTO&gt; queue = redissonClient.getQueue(dataKey);
        // 尝试加锁，最多等待20秒，上锁以后30秒自动解锁
        boolean lockRes = rLock.tryLock(20 * 1000, 3 * retryInterval,TimeUnit.MILLISECONDS);
        //拿到锁且 队列不为空 进入
        if (lockRes &amp;&amp; !queue.isEmpty()) {
            //让这个线程把队列里的全部处理完吧
            rLock.lock();
            //DATA_KEY_IN_PROCESS.add(dataKey);
            while ((dto = queue.peek()) != null) {
                //处理完毕，把数据从队列摘除
                boolean handleRes = doHandleWithLock(dto, 0);
                if (handleRes) {
                    queue.remove();
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
        log.severe(&quot;接收处理数据失败：&quot; + e.toString());
    } finally {
        rLock.forceUnlock();
        rLock.delete();
        //DATA_KEY_IN_PROCESS.remove(dataKey);
    }
}
</code></pre>
<p>猜测是redis RLock并没有效，于是在rLock.tryLock() 和 rLock.delete() 方法后面分别打印出 acquireLock 和 releaseLock的日志，再次执行测试，得到如下日志：<br>
<img src="https://gitchenjh.github.io//post-images/1563160191203.jpg" alt=""></p>
<p>发现 pool-2-thread-1线程成功获取锁后，pool-2-thread-2获取锁失败，并立刻将pool-2-thread-1 持有的锁release了。结合源码发现pool-2-thread-2获取锁失败后，执行了finally代码块中的rLock.forceUnlock()方法，查阅资料发现forceUnlock()方法可以直接释放相同key的其他线程持有的锁。</p>
<p>至此，定位到问题为：每次收到数据起一个线程执行doRunWithLock()方法，当数据库操作较频繁时，一个线程获取到的redis锁会被另一个线程release掉，导致redis锁内部本来应该是单例执行的消费redis队列数据变成了多个线程同时执行，从而出现多个线程消费队列数据冲突，引发数据丢失和重复消费的问题。</p>
<h2 id="解决">解决</h2>
<p>确保每个线程获取到的Redis锁只能由当前线程release()，更改后的代码如下：</p>
<pre><code class="language-java">private void doRunWithLock() {
    RLock rLock = redissonClient.getLock(dataKeyLock);
    EventBaseDTO dto;
    boolean lockRes = false;
    try {
        // 尝试加锁，最多等待50ms(防止过多线程等待)
        // 上锁以后6个小时自动解锁(防止redis队列太长，当前拿到锁的线程处理时间过长)
        lockRes = rLock.tryLock(50, 6 * 3600 * 1000, TimeUnit.MILLISECONDS);
        if (!lockRes) {
            return;
        }
        DATA_KEY_IN_PROCESS.add(dataKey);
        //拿到锁之后再获取队列
        RQueue&lt;EventBaseDTO&gt; queue = redissonClient.getQueue(dataKey);
        if (!queue.isExists() || queue.isEmpty()) {
            return;
        }
        //拿到锁且 队列不为空 进入
        while ((dto = queue.peek()) != null) {
            //处理完毕，把数据从队列摘除
            boolean handleRes = doHandleWithLock(dto, 0);
            if (handleRes) {
                queue.remove();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
        log.severe(&quot;接收处理数据失败：&quot; + e.toString());
 
    } finally {
        //forceUnlock是可以释放别的线程拿到的锁的，需要判断是否是当前线程持有的锁
        if (lockRes) {
            rLock.forceUnlock();
            rLock.delete();
            DATA_KEY_IN_PROCESS.remove(dataKey);
        }
    }
}
</code></pre>
<h2 id="回归">回归</h2>
<p>更改后执行继续执行相同的测试用例，得到如下结果日志：<br>
<img src="https://gitchenjh.github.io//post-images/1563160200151.jpg" alt=""></p>
<p>pool-2-thread-2在获取到redis锁之后一直持续消费redis队列中的数据，其他线程尝试获取redis锁失败后，不再强制release该锁，客户端消费条数、类型结果正确。</p>
<h2 id="完成">完成</h2>
<p>修改测试用例，使用更多线程、执行更多数据库操作，分析消费结果，结果数据条数正确，未出现数据丢失、重复消费等问题。<br>
确认结果回归结果正确，提交代码。</p>
<h2 id="作者简介">作者简介</h2>
<p>陈精华，2018年8月加入凯京科技。任职java开发工程师，参与凯京科技统一支付平台、结算平台设计和开发，负责凯京科技开源中间件开发与维护。</p>
<p>欢迎加入凯京开源技术QQ群：613025121，和我们一起交流互联网应用的技术架构落地实践<br>
<img src="https://gitchenjh.github.io//post-images/1563160245009.png" alt=""></p>
<h2 id="关于架构运维部">关于架构&amp;运维部</h2>
<p>凯京研发中心架构&amp;运维部的工作主要分两大部分，架构部分主要负责框架中间件的研究，如dubbo、apollo、skywalking、xxljob、分布式事务等、公司内<a href="https://gitee.com/kekingcn">开源项目</a>以及公共服务公共组件的研发维护、新技术的引进以及落地等。运维部分主要负责devops系统研发以及k8s容器环境的维护等工作。</p>
<h2 id="架构组招聘">架构组招聘</h2>
<p>目前架构组还有一个虚位以待，欢迎志同道合的你来和我们一起交流。简历可发送至邮箱：<br>
chenkailing@keking.cn</p>
]]></content>
    </entry>
</feed>