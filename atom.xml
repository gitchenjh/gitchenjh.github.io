<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gitchenjh.github.io/</id>
    <title>gitchenjh 博客</title>
    <updated>2019-07-22T02:06:37.452Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gitchenjh.github.io/"/>
    <link rel="self" href="https://gitchenjh.github.io//atom.xml"/>
    <subtitle>gitchenjh 博客</subtitle>
    <logo>https://gitchenjh.github.io//images/avatar.png</logo>
    <icon>https://gitchenjh.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, gitchenjh 博客</rights>
    <entry>
        <title type="html"><![CDATA[适用于spring-boot项目的反爬虫组件kk-anti-reptile]]></title>
        <id>https://gitchenjh.github.io//post/kk-anti-reptile</id>
        <link href="https://gitchenjh.github.io//post/kk-anti-reptile">
        </link>
        <updated>2019-07-19T03:03:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-概述">1. 概述</h2>
<p>kk-anti-reptile是<a href="https://www.keking.com">凯京科技</a>研发的，适用于<code>基于spring-boot开发的分布式系统</code>的反爬虫组件。</p>
<h2 id="2-系统要求">2. 系统要求</h2>
<ul>
<li>基于spring-boot开发(spring-boot1.x, spring-boot2.x均可)</li>
<li>需要使用redis</li>
</ul>
<h2 id="3-工作流程">3. 工作流程</h2>
<p>kk-anti-reptile使用基于Servlet规范的的Filter对请求进行过滤，在其内部通过spring-boot的扩展点机制，实例化一个Filter，并注入到Spring容器FilterRegistrationBean中，通过Spring注入到Servlet容器中，从而实现对请求的过滤</p>
<p>在kk-anti-reptile的过滤Filter内部，又通过责任链模式，将各种不同的过滤规则织入，并提供抽象接口，可由调用方进行规则扩展</p>
<p>Filter调用则链进行请求过滤，如过滤不通过，则拦截请求，返回状态码<code>509</code>，并输出验证码输入页面，输出验证码正确后，调用过滤规则链对规则进行重置</p>
<p>目前规则链中有如下两个规则</p>
<h3 id="ip-rule">ip-rule</h3>
<p>ip-rule通过时间窗口统计当前时间窗口内请求数，小于规定的最大请求数则可通过，否则不通过。时间窗口、最大请求数、ip白名单等均可配置</p>
<h3 id="ua-rule">ua-rule</h3>
<p>ua-rule通过判断请求携带的User-Agent，得到操作系统、设备信息、浏览器信息等，可配置各种维度对请求进行过滤</p>
<h2 id="4-接入使用">4. 接入使用</h2>
<p>后端接入非常简单，只需要引用kk-anti-reptile的maven依赖，并配置启用kk-anti-reptile即可<br>
加入maven依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;cn.keking.project&lt;/groupId&gt;
    &lt;artifactId&gt;kk-anti-reptile&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>配置启用 kk-anti-reptile</p>
<pre><code class="language-properties">anti.reptile.manager.enabled=true
</code></pre>
<p>前端需要在统一发送请求的ajax处加入拦截，拦截到请求返回状态码<code>509</code>后弹出一个新页面，并把响应内容转出到页面中，然后向页面中传入后端接口<code>baseUrl</code>参数即可，以使用axios请求为例：</p>
<pre><code class="language-javascript">import axios from 'axios';
import {baseUrl} from './config';

axios.interceptors.response.use(
  data =&gt; {
    return data;
  },
  error =&gt; {
    if (error.response.status === 509) {
      let html = error.response.data;
      let verifyWindow = window.open(&quot;&quot;,&quot;_blank&quot;,&quot;height=400,width=560&quot;);
      verifyWindow.document.write(html);
      verifyWindow.document.getElementById(&quot;baseUrl&quot;).value = baseUrl;
    }
  }
);

export default axios;
</code></pre>
<p>凯京科技内部用户可以访问 https://git.keking.cn/infrastructure/kk-antireptile-demo 查看接入示例</p>
<h2 id="5-注意">5. 注意</h2>
<ol>
<li>apollo-client需启用bootstrap</li>
</ol>
<p>使用apollo配置中心的用户，由于组件内部用到<code>@ConditionalOnProperty</code>，要在application.properties/bootstrap.properties中加入如下样例配置，(apollo-client需要0.10.0及以上版本）详见<a href="https://github.com/ctripcorp/apollo/wiki/Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97#3213-spring-boot%E9%9B%86%E6%88%90%E6%96%B9%E5%BC%8F%E6%8E%A8%E8%8D%90">apollo bootstrap说明</a></p>
<pre><code class="language-properties">apollo.bootstrap.enabled = true
</code></pre>
<ol start="2">
<li>需要有Redisson连接</li>
</ol>
<p>如果项目中有用到Redisson，kk-anti-reptile会自动获取RedissonClient实例对象; 如果没用到，需要在配置文件加入如下Redisson连接相关配置</p>
<pre><code class="language-properties">spring.redisson.address=redis://192.168.1.204:6379
spring.redisson.password=xxx
</code></pre>
<h2 id="6-配置一览表">6. 配置一览表</h2>
<p>在spring-boot中，所有配置在配置文件都会有自动提示和说明，如下图<br>
<img src="https://gitchenjh.github.io//post-images/1563505482779.png" alt="配置自动提示及说明"><br>
所有配置都以<code>anti.reptile.manager</code>为前缀，如下为所有配置项及说明</p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>描述</th>
<th>默认值</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>enabled</td>
<td>是否启用反爬虫插件</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>includeUrls</td>
<td>需要反爬的接口列表，以'/'开头，以','分隔</td>
<td>空</td>
<td>/client,/user</td>
</tr>
<tr>
<td>ip-rule.enabled</td>
<td>是否启用IP Rule</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>ip-rule.expiration-time</td>
<td>时间窗口长度(ms)</td>
<td>5000</td>
<td>5000</td>
</tr>
<tr>
<td>ip-rule.request-max-size</td>
<td>单个时间窗口内，最大请求数</td>
<td>20</td>
<td>20</td>
</tr>
<tr>
<td>ip-rule.ignore-ip</td>
<td>IP白名单，支持后缀'*'通配，以','分隔</td>
<td>空</td>
<td>192.168.*,127.0.0.1</td>
</tr>
<tr>
<td>ua-rule.enabled</td>
<td>是否启用User-Agent Rule</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>ua-rule.allowed-linux</td>
<td>是否允许Linux系统访问</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>ua-rule.allowed-mobile</td>
<td>是否允许移动端设备访问</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>ua-rule.allowed-pc</td>
<td>是否允许移PC设备访问</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>ua-rule.allowed-iot</td>
<td>是否允许物联网设备访问</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>ua-rule.allowed-proxy</td>
<td>是否允许代理访问</td>
<td>true</td>
<td>true</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[bin-log-distributor消费数据丢失问题解决记录]]></title>
        <id>https://gitchenjh.github.io//post/bin-log-distributor_problem</id>
        <link href="https://gitchenjh.github.io//post/bin-log-distributor_problem">
        </link>
        <updated>2018-10-22T03:02:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="bin-log-distributor项目简介">bin-log-distributor项目简介</h2>
<p>bin-log-distributor是凯京科技开源的Mysql数据库数据变动实时监听分发中间件，详情见<a href="https://gitee.com/kekingcn/keking-binlog-distributor">码云开源地址</a>, <a href="https://github.com/kekingcn/keking-binlog-distributor">github开源地址</a></p>
<h2 id="背景">背景</h2>
<p>线上反馈有bin-log-distributor客户端偶尔有丢失数据的情况。</p>
<h2 id="验证方法">验证方法</h2>
<p>在装mysql的服务器上，使用多个线程并发循环对bin-log-distributor监控的数据表进行增、删、改。</p>
<h2 id="预期">预期</h2>
<p>bin-log-distributor客户端出现数据丢失。</p>
<h2 id="定位">定位</h2>
<p>分析客户端收到的数据，发现不仅有数据丢失，还有数据重复消费。<br>
将客户端日志打印更仔细，发现以下两点问题：</p>
<ol>
<li>从redis队列peek数据后，remove抛出如下异常：<br>
<img src="https://gitchenjh.github.io//post-images/1563160157405.jpg" alt=""></li>
<li>Redis队列数据没消费完其他线程异常进行了消费：<br>
<img src="https://gitchenjh.github.io//post-images/1563160179721.jpg" alt=""></li>
</ol>
<p>分析如下消费redis数据方法源码：</p>
<pre><code class="language-java">private void doRunWithLock() {
    RLock rLock = redissonClient.getLock(dataKeyLock);
    EventBaseDTO dto;
    try {
        RQueue&lt;EventBaseDTO&gt; queue = redissonClient.getQueue(dataKey);
        // 尝试加锁，最多等待20秒，上锁以后30秒自动解锁
        boolean lockRes = rLock.tryLock(20 * 1000, 3 * retryInterval,TimeUnit.MILLISECONDS);
        //拿到锁且 队列不为空 进入
        if (lockRes &amp;&amp; !queue.isEmpty()) {
            //让这个线程把队列里的全部处理完吧
            rLock.lock();
            //DATA_KEY_IN_PROCESS.add(dataKey);
            while ((dto = queue.peek()) != null) {
                //处理完毕，把数据从队列摘除
                boolean handleRes = doHandleWithLock(dto, 0);
                if (handleRes) {
                    queue.remove();
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
        log.severe(&quot;接收处理数据失败：&quot; + e.toString());
    } finally {
        rLock.forceUnlock();
        rLock.delete();
        //DATA_KEY_IN_PROCESS.remove(dataKey);
    }
}
</code></pre>
<p>猜测是redis RLock并没有效，于是在rLock.tryLock() 和 rLock.delete() 方法后面分别打印出 acquireLock 和 releaseLock的日志，再次执行测试，得到如下日志：<br>
<img src="https://gitchenjh.github.io//post-images/1563160191203.jpg" alt=""></p>
<p>发现 pool-2-thread-1线程成功获取锁后，pool-2-thread-2获取锁失败，并立刻将pool-2-thread-1 持有的锁release了。结合源码发现pool-2-thread-2获取锁失败后，执行了finally代码块中的rLock.forceUnlock()方法，查阅资料发现forceUnlock()方法可以直接释放相同key的其他线程持有的锁。</p>
<p>至此，定位到问题为：每次收到数据起一个线程执行doRunWithLock()方法，当数据库操作较频繁时，一个线程获取到的redis锁会被另一个线程release掉，导致redis锁内部本来应该是单例执行的消费redis队列数据变成了多个线程同时执行，从而出现多个线程消费队列数据冲突，引发数据丢失和重复消费的问题。</p>
<h2 id="解决">解决</h2>
<p>确保每个线程获取到的Redis锁只能由当前线程release()，更改后的代码如下：</p>
<pre><code class="language-java">private void doRunWithLock() {
    RLock rLock = redissonClient.getLock(dataKeyLock);
    EventBaseDTO dto;
    boolean lockRes = false;
    try {
        // 尝试加锁，最多等待50ms(防止过多线程等待)
        // 上锁以后6个小时自动解锁(防止redis队列太长，当前拿到锁的线程处理时间过长)
        lockRes = rLock.tryLock(50, 6 * 3600 * 1000, TimeUnit.MILLISECONDS);
        if (!lockRes) {
            return;
        }
        DATA_KEY_IN_PROCESS.add(dataKey);
        //拿到锁之后再获取队列
        RQueue&lt;EventBaseDTO&gt; queue = redissonClient.getQueue(dataKey);
        if (!queue.isExists() || queue.isEmpty()) {
            return;
        }
        //拿到锁且 队列不为空 进入
        while ((dto = queue.peek()) != null) {
            //处理完毕，把数据从队列摘除
            boolean handleRes = doHandleWithLock(dto, 0);
            if (handleRes) {
                queue.remove();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
        log.severe(&quot;接收处理数据失败：&quot; + e.toString());
 
    } finally {
        //forceUnlock是可以释放别的线程拿到的锁的，需要判断是否是当前线程持有的锁
        if (lockRes) {
            rLock.forceUnlock();
            rLock.delete();
            DATA_KEY_IN_PROCESS.remove(dataKey);
        }
    }
}
</code></pre>
<h2 id="回归">回归</h2>
<p>更改后执行继续执行相同的测试用例，得到如下结果日志：<br>
<img src="https://gitchenjh.github.io//post-images/1563160200151.jpg" alt=""></p>
<p>pool-2-thread-2在获取到redis锁之后一直持续消费redis队列中的数据，其他线程尝试获取redis锁失败后，不再强制release该锁，客户端消费条数、类型结果正确。</p>
<h2 id="完成">完成</h2>
<p>修改测试用例，使用更多线程、执行更多数据库操作，分析消费结果，结果数据条数正确，未出现数据丢失、重复消费等问题。<br>
确认结果回归结果正确，提交代码。</p>
<h2 id="作者简介">作者简介</h2>
<p>陈精华，2018年8月加入凯京科技。任职java开发工程师，参与凯京科技统一支付平台、结算平台设计和开发，负责凯京科技开源中间件开发与维护。</p>
<p>欢迎加入凯京开源技术QQ群：613025121，和我们一起交流互联网应用的技术架构落地实践<br>
<img src="https://gitchenjh.github.io//post-images/1563160245009.png" alt=""></p>
<h2 id="关于架构运维部">关于架构&amp;运维部</h2>
<p>凯京研发中心架构&amp;运维部的工作主要分两大部分，架构部分主要负责框架中间件的研究，如dubbo、apollo、skywalking、xxljob、分布式事务等、公司内<a href="https://gitee.com/kekingcn">开源项目</a>以及公共服务公共组件的研发维护、新技术的引进以及落地等。运维部分主要负责devops系统研发以及k8s容器环境的维护等工作。</p>
<h2 id="架构组招聘">架构组招聘</h2>
<p>目前架构组还有一个虚位以待，欢迎志同道合的你来和我们一起交流。简历可发送至邮箱：<br>
chenkailing@keking.cn</p>
]]></content>
    </entry>
</feed>